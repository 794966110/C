#include<stdio.h>
#include<stdlib.h>
#define maxsize 50
typedef char ElemType;
typedef struct node
{
	ElemType data;
	struct node* lchild, * rchild;//指向左孩子和右孩子
}BTNode;//二叉链

void createTree(BTNode**b,char *str)//根据字符串str生产对应二叉数
{
	BTNode* St[maxsize];BTNode* p;//p为子结点
	int i = 0;char ch;int top=-1;//top栈顶指针
	int k;//区分左右结点
	ch = str[i];
	(*b) = NULL;
	while (ch!='\0')
	{
		switch (ch)
		{
		case '(':top++;St[top] = p;k = 1;break;//之后检测左结点
		case ')':top--;break;//回到上双亲结点
		case ',':k = 2;break;//之后检测右结点
		default://数据
			p = (BTNode*)malloc(sizeof(BTNode));
			p->data = ch;
			p->lchild = p->rchild = NULL;
			if (*b == NULL)//连接跟结点
			{
				*b = p;
			}
			else
			{
				switch (k)//连接子结点
				{
				case 1:St[top]->lchild = p;break;
				case 2:St[top]->rchild = p;break;
				default:printf("error");
				}
			}
		}//switch
		i++;
		ch = str[i];
	}//while
}

void destory(BTNode** b)//递归销毁二叉链
{
	if ((*b) == NULL)
		return;
	else
	{
		destory(&((*b)->lchild));
		destory(&((*b)->rchild));
		free((*b));
	}
}

BTNode* LChildNode(BTNode*p)//返回p结点的左孩子的指针
{
	return p->lchild;
}

BTNode* RChildNode(BTNode* p)//返回p结点的右孩子的指针
{
	return p->rchild;
}

BTNode *FindNdoe(BTNode* b, ElemType x)//在二叉树b中寻找data域值为x的结点，并返回指向该结点的指针
{
	BTNode* p;
	if (b == NULL)
	{
		return NULL;
	}
	else if(b->data==x)//递归出口
	{
		return b;
	}
	else//往下层搜索
	{
		p=FindNdoe(b->lchild, x);
		if (p != NULL)return p;//如果找到借助p向外返回
		else //左结点未找到，搜索右结点
			return FindNdoe(b->rchild, x);
	}
}



void dispBTree(BTNode* b)//括号表示发输出一颗二叉树
{
	if (b != NULL)
	{
		printf("%c", b->data);
		if (b->lchild != NULL||b->rchild!=NULL)
		{
			printf("(");
			dispBTree(b->lchild);
			if (b->rchild != NULL)
			{
				printf(",");
			}
			dispBTree(b->rchild);
			printf(")");
		}
	}
}

//int BTHeight1(BTNode* b)//求树高1
//{
//	int hmax=0,h1,h2;
//	if (b == NULL)
//	{
//		return 0;
//	}
//	else
//	{
//		h1=BTHeight(b->lchild);	
//		if (h1 > hmax)
//		{
//			hmax = h1;
//		}
//		h2 = BTHeight(b->rchild);
//		if (h2 > hmax)
//		{
//			hmax = h2;
//		}
//	}
//	return hmax + 1;
//}

int BTHeight2(BTNode* b)//求树高2
{
	int h1, h2;
	if (b == NULL)//递归出口
	{
		return 0;
	}
	else
	{
		h1=BTHeight2(b->lchild);
		h2=BTHeight2(b->rchild);
		return h1 > h2 ? (h1 + 1) : (h2 + 1);
	}
}

int main()
{	
	BTNode* b, * p;
	createTree(&b,"A(B(D(,G)),C(E,F))");
	printf("%c\n", FindNdoe(b, 'G')->data);
	dispBTree(b);//输出二叉树
	printf("\nA的左孩子为：%c\n", LChildNode(b)->data);//输出A的左孩子
	printf("树高为：%d\n", BTHeight2(b));
	destory(&b);
	return 0;
}
